
/******************************************************************************

Версия IDE: Microsoft Visual Studio Community 2022 v.17.2.3
(дополнительное тестирование на Code::Blocks 20.03)

*******************************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <math.h>
#include <assert.h>

/* Определение размеров игрового поля: */
#define width 65 // ширина
#define height 25 // высота

/* Структура для ракетки:
TRacket - имя структурного типа для ракетки*/
typedef struct {
	int x, y; // положение по оси x и y
	int w; // ширина
	int fireMode; // режим стрельбы
} TRacket;

/* Структура для объектов:
TBall - имя структурного типа для мячика;
TObj - имя структурного типа для призов */
typedef struct {
	float x, y; // чтобы мячик двигался по диагонали
	int ix, iy; // дополнительные целые и округлённые координаты мячика
	float alfa; // угол направления движения
	float speed; // скорость движения
	char type; // тип объекта
	char del; // объект больше не используется и его можно удалить
} TBall, TObj;

/* Макросы игрового поля: */
#define c_border '#' // границы и барьеры
#define c_racket '@' // ракетка
#define c_brick (char)176 // разбиваемые кирпичи (символ ░ таблицы ASCII)
#define brickWidth 3 // ширина одного кирпича 3 символа строки

char lvlMap[height][width]; // двумерный массив lvlMap хранит карту уровня
char mas[height][width + 1]; // mas хранит игровое поле по высоте и ширине, width + 1 предотвращает заполнение игрового поля символом '#'
TRacket racket; // инициализируем переменную типа TRacket для работы с ракеткой racket
TBall ball; // инициализируем переменную типа TBall для работы с мячиком ball
int hitCnt = 0; // инициализируем переменную количества ударов мячика о ракетку
int maxHitCnt = 0; // инициализируем переменную максимального количества ударов
int lvl = 1; // начинать игру с Уровня 1
boolean run = FALSE; // булева переменная run изначально привязывает мячик к ракетке (FALSE)

/* Массив для хранения игровых объектов (призов): */
#define objArrSize 1000 // может хранить максимум 1000 объектов
TObj objArr[objArrSize]; // сам массив objArr
int objArrCnt = 0; // текущее кол-во объектов

/* Макросы игровых объектов или призов (падающих улучшений): */
#define ot_wide 'W' // ракетка растягивается
#define ot_thin 'T' // ракетка сужается
#define ot_fire 'F' // ракетка переходит в режим стрельбы
#define ot_bullet '.' // пули
#define objUpgradeTypesRandMax 7 // рандомизатор случайных объектов на уровень
char objUpgradeTypes[] = { ot_wide, ot_thin, ot_fire }; // массив для выбора типа обекта, который изменяет ракетку
int objUpgradeTypesCnt = sizeof(objUpgradeTypes) / sizeof(objUpgradeTypes[0]); // количество элементов в массиве

/* Объявление функций до их первого использования: */
void moveBall(float x, float y); // движение мячика
void setcur(int x, int y); // поместить курсор в обозначенное место
char Obj_HitBrick(TObj ball); // события при столкновении с кирпичами

/* Функция создания объекта: */
TObj Obj_Create(float x, float y, float a, float spd, char chr)
{
	/*
	Классический синтаксис С для компилятора gcc,
	не поддерживается компилятором Visual Studio:
	//return (TObj) { x, y, (int)x, (int)y, a, spd, chr };
	*/

	/* Универсальный синтаксис для всех компиляторов: */
	TObj temp = { x, y, (int)x, (int)y, a, spd, chr }; // для целочисленных переменных отбрасываем дробную часть
	return temp;
}

/* Функция помещения объекта на карту: */
void Obj_Put(TObj obj)
{
	/* т.к. это второстепенные объекты, то выводим их на карту только если там ничего нет;
	таким образом, объекты будут сохранять функционал для столкновений, т.к. для столкновений
	мы анализируем массив mas: */
	if (mas[obj.iy][obj.ix] == ' ')
		mas[obj.iy][obj.ix] = obj.type;
}

/* Функция корректировки угла движения: */
void CorrectAngle(float* a)
{
	/* чтобы угол был от 0 до 2π: */
	if (*a < 0) *a += M_PI * 2;
	if (*a > M_PI * 2) *a -= M_PI * 2;
}

/* Функция перемещения падающего объекта по направлению: */
void Obj_Move(TObj* obj)
{
	CorrectAngle(&obj->alfa);
	obj->x += cos(obj->alfa) * obj->speed;
	obj->y += sin(obj->alfa) * obj->speed;
	obj->ix = (int)obj->x;
	obj->iy = (int)obj->y;
}

/* Функция поимки объекта ракеткой: */
void Obj_WorkUpgrade(TObj* obj)
{
	if (mas[obj->iy][obj->ix] != c_racket) return; // если объект не на ракетке, то выходим

	/* если объект на ракетке - двигаемся дальше и, в зависимости от типа объекта, применяем его свойства,
	после чего помечаем объект как удалённый, и после применения эффекта этот объект уничтожается: */
	if (obj->type == ot_wide) racket.w = min(racket.w + 1, 15), obj->del = 1; // ракетка расширяется
	if (obj->type == ot_thin) racket.w = max(racket.w - 1, 5), obj->del = 1; // ракетка сужается
	if (obj->type == ot_fire) // режим стрельбы:
	{
		if (racket.fireMode < 1) racket.fireMode = 1; // при поимке объекта, возникает возможность стрелять,..
		obj->del = 1; // ...а сам объект удаляется
	}
}

/* Функция-обработчик для пулек: */
void Obj_WorkBullet(TObj* obj)
{
	if (obj->type != ot_bullet) return; // если объект не пуля - выходим,..
	if (Obj_HitBrick(*obj) || mas[obj->iy][obj->ix] == c_border) // ...а если пуля, то при попадании по кирпичу или стене...
		obj->del = 1; // ...удаляем объект
}

/* Функция для работы с объектом: */
void Obj_Work(TObj* obj)
{
	Obj_Move(obj);
	Obj_WorkUpgrade(obj);
	Obj_WorkBullet(obj);
}

/* Функция добавления объекта в массив: */
void ObjArr_Add(TObj obj)
{
	assert(objArrCnt + 1 < objArrSize);
	objArr[objArrCnt] = obj;
	objArrCnt++;
}

/* Функция удаления объекта из массива: */
void ObjArr_DelPos(int pos)
{
	if (pos < 0 || pos >= objArrCnt) return; // удаляем только существующие обекты
	objArr[pos] = objArr[objArrCnt - 1]; // для этого переносим последний активный объект на место удаляемого...
	objArrCnt--; // ...и уменьшаем общее количество объектов в массиве на 1
}

/* Функция обработки всех объектов в массиве: */
void ObjArr_Work()
{
	int i = 0;
	while (i < objArrCnt) // проходим по всем активным элементам... 
	{
		Obj_Work(objArr + i); // ...и они выполняют свои функции
		if (objArr[i].y < 0 || objArr[i].y > height || objArr[i].del) // если объект вышел за границы экрана или помечен как удалённый...
			ObjArr_DelPos(i); // ...удаляем объект из массива
		else // если объект не удалился,..
			i++; // ...переходим к следующему элементу массива
	}
}

/* Функция помещения всех объектов на карту: */
void ObjArr_Put()
{
	/* кладём на карту все объекты: */
	for (int i = 0; i < objArrCnt; i++)
		Obj_Put(objArr[i]);
}

/* Функция очистки массива: */
void ObjArr_Clear() { objArrCnt = 0; }

/* Функция инициализирует мячик: */
void initBall()
{
	moveBall(2, 2); // задаём исходные координаты движения мячика
	ball.alfa = -1; // инициализируем угол движения мячика...
	ball.speed = 0.5; // ...и его скорость
}

/* Функция помещает мячик на экран: */
void putBall()
{
	mas[ball.iy][ball.ix] = '*'; // обозначим мячик символом '*'
}

/* Функция движения мячика по экрану: */
void moveBall(float x, float y) // float - для рассчёта движения по диагонали
{
	/* координаты по x и у: */
	ball.x = x;
	ball.y = y;

	/* округлить round и привести к целому int: */
	ball.ix = (int)round(ball.x);
	ball.iy = (int)round(ball.y);
}

/* Функция генерации падающего объекта: */
void Obj_ChanceCreateRandomUpgradeObject(float x, float y)
{
	int i = rand() % objUpgradeTypesRandMax; // генерируем случайное число
	if (i < objUpgradeTypesCnt) // если оно позволяет выбрать элемент массива,..
		ObjArr_Add(Obj_Create(x, y, M_PI_2, 0.2, objUpgradeTypes[i])); // ...то генерируем объект
}

/* Функция столкновения с кирпичами: */
char Obj_HitBrick(TObj ball)
{
	if (mas[ball.iy][ball.ix] == c_brick) // если шарик столкнулся с кирпичом,..
	{
		if (lvlMap[ball.iy][ball.ix] == c_brick) // ...и если кирпич до сих пор находится на карте уровня,..
			Obj_ChanceCreateRandomUpgradeObject(ball.x, ball.y); // ...то генерируем падающий объект

		/* получаем номер кирпича, чтобы, при попадании по одному символу в строке,
		разбивался весь кирпич, состоящий из 3 символов */
		int brickNom = (ball.ix - 1) / brickWidth; // -1, чтобы не учитывать границу карты

		/* получаем положение первого символа кирпича */
		int dx = 1 + brickNom * brickWidth; // 1+, чтобы получить координаты

		/* теперь проходим в цикле по всем трём символам кирпича */
		for (int i = 0; i < brickWidth; i++)
		{
			static char* c;
			c = &lvlMap[ball.iy][i + dx];
			if (*c == c_brick) *c = ' '; // если это тело кирпича, то удаляем его с карты
		}
		return 1; // если попали по кирпичу - возвращаем 1
	}
	return 0; // если не попали - возвращаем 0
}

/* Функция автоматического движения мячика: */
void autoMoveBall()
{
	/* приводим угол alfa к значению от 0 до 2π: */
	if (ball.alfa < 0) ball.alfa += M_PI * 2;
	if (ball.alfa > M_PI * 2) ball.alfa -= M_PI * 2;

	TBall bl = ball; // перед перемещением сохраним значение мячика

	/* изменяем координаты мячика по x и y
	в зависимости от угла alfa и скорости speed: */
	moveBall(ball.x + cos(ball.alfa) * ball.speed,
		ball.y + sin(ball.alfa) * ball.speed);

	/* проверяем, столкнулся ли мячик со стеной, с ракеткой или с кирпичом: */
	if ((mas[ball.iy][ball.ix] == c_border) || // столкновение мячика со стеной
		(mas[ball.iy][ball.ix] == c_brick) || // столкновение мячика с кирпичом
		(mas[ball.iy][ball.ix] == c_racket)) // столкновение мячика с ракеткой
	{
		Obj_HitBrick(ball); // вызвать функцию столкновения с кирпичами

		/* рассчитываем количество удоров мячика о ракетку: */
		if (mas[ball.iy][ball.ix] == c_racket) // если мячик отразился от ракетки,..
		{
			hitCnt++; // ...увеличиваем значение переменной hitCnt на 1

			/* уточняем угол полёта мячика, в зависимости
			от того, куда он попал на самой ракетке: */
			float pos = ball.x - racket.x; // вычисляем место на ракетке, куда попал мячик
			float psi = pos / racket.w * 2; // получаем число ≈ от 0 до 2
			psi = (psi - 1) * M_PI_2 * 0.9; // ≈ от -1 до +1, ≈ от -π/2 до +π/2, умножаем на 0.9, чтобы немного приподнять максимально возможные углы
			assert(psi < M_PI_2&& psi > -M_PI_2); // assert на случай, если мы ошибёмся в формуле 
			bl.alfa = -M_PI_2 + psi; // угол -π/2 - это направление вверх; прибавив к нему угол psi, получаем разброс в направлениях мячика
		}
		else if ((ball.ix != bl.ix) && (ball.iy != bl.iy)) // сравниваем новое положение мячика ball. и его старое положение bl.
		{
			if (mas[bl.iy][ball.ix] == mas[ball.iy][bl.ix]) // проверяем, если старые и новые клетки, между которыми пролетел мячик, равны,..
				bl.alfa = bl.alfa + M_PI; // ...то это угол (просто инвертируем движение мячика);..
			else // ...если они не равны,..
			{
				if (mas[bl.iy][ball.ix] == c_border)
					bl.alfa = (2 * M_PI - bl.alfa) + M_PI; // ... то это стена (отражаем по вертикали),..
				else
					bl.alfa = (2 * M_PI - bl.alfa); // ...или потолок (отражаем по горизонтали)
			}
		}

		/* если изменилась какая-то одна координата мячика,
		то отражаем его по вертикали или горизонтали: */
		else if (ball.iy == bl.iy) // если y не менялся,..
			bl.alfa = (2 * M_PI - bl.alfa) + M_PI; // ...то мячик нужно отразить по вертикали
		else // в противном случае не менялся x,..
			bl.alfa = (2 * M_PI - bl.alfa); // ...поэтому отражаем мячик по горизонтали

		ball = bl; // пересчёт координат мячика
	}
}

/* Функция инициализирует ракетку: */
void initRacket()
{
	racket.w = 7; // исходная ширина ракетки 7 символов
	racket.x = (width - racket.w) / 2; // по оси x ракетка находится в центре карты
	racket.y = height - 1; // по оси y ракетка находится внизу локации
	racket.fireMode = 0; // изначально режим стрельбы не активен
}

/* Функция помещает ракетку на экран: */
void putRacket()
{
	for (int i = racket.x; i < racket.x + racket.w; i++) // рисуем ракетку из точки x на всю ширину w...
		mas[racket.y][i] = c_racket; // ...и формируем масив символов c_racket, соответствующий @
	if (racket.fireMode > 0) // если режим стрельбы активен,..
		mas[racket.y - 1][racket.x + racket.w / 2] = '|'; // ...то рисуем дуло '|' в центре ракетки
}

/* Функция осуществляет переход на следующий уровень, каждый со своим наполнением: */
void lvlMapPuzzile(int lvl)
{
	/* на Уровне 1 имеется двойная горизонтальная стена из разрушаемых
	кирпичей на 6 и 7 строках и отступом слева и справа в 7 символов */
	if (lvl == 1)
	{
		for (int i = 7; i < width - 7; i++)
			lvlMap[5][i] = lvlMap[6][i] = c_brick;
	}

	/* на Уровне 2 имеются две двойные горизонтальные стены из разрушаемых
	кирпичей на 1, 2 и 8, 9 строках, а также  препятствие на 10 строке
	(везде отступ слева 20 символов, ширина равна 30, т.к. не должна превышать
	50, а отступ справа 15, т.к. общая ширина игрового поля с границами = 65 символов */
	if (lvl == 2)
		for (int i = 20; i < 50; i++)
		{
			lvlMap[1][i] = lvlMap[2][i] = c_brick;
			lvlMap[8][i] = lvlMap[9][i] = c_brick;
			lvlMap[10][i] = c_border;
		}

	/* на Уровне 3 начиная с ячейки [1] создаются столбцы высотой менее 10 (т.е. 9) символов,
	шириной 3 символа каждый и отступом 3 символа между каждым столбцом (i += 6), при этом они
	не должны выходить за границы игрового поля (i < 65); таким образом, получится 11 столбцов
	и 10 промежутков между ними в 3 символа */
	if (lvl == 3)
	{
		for (int j = 1; j < 10; j++)
			for (int i = 1; i < 65; i += 6)
				lvlMap[j][i] = lvlMap[j][i + 1] = lvlMap[j][i + 2] = c_brick;
	}
}

/* Функция заполняет карту локации содержимым: */
void lvlMapInit(int lvl)
{
	/* заполняем всё игровое поле пустым сиволом ' ' */
	memset(lvlMap, ' ', sizeof(lvlMap));

	lvlMapPuzzile(lvl); // вызов карты уровня

	/* формируем границы игрового поля: */
	for (int i = 0; i < width; i++)
		lvlMap[0][i] = c_border;
	for (int j = 0; j < height; j++)
		lvlMap[j][0] = lvlMap[j][width - 1] = c_border;
}

/* Функция копирует уровень в буфер вывода на экран: */
void lvlMapPut()
{
	/* перед выводом локации заполняем mas (именно его выводим на экран) нулями;
	далее копируем всё из карты уровня lvlMap в буфер вывода mas, при этом последний
	символ mas является '\0', т.е. концом строки: */
	memset(mas, 0, sizeof(mas));
	for (int j = 0; j < height; j++)
		memcpy(mas[j], lvlMap[j], sizeof(**lvlMap) * width);
}

/* Функция показа игрового поля и статистических данных: */
void show()
{
	setcur(0, 0); // предотвращаем мерцание экрана

	/* игровое поле формируется с [0] строки массива до тех пор, пока оно
	меньше указанной высоты 25, т.е. адрес последней строки поля [24]: */
	for (int i = 0; i < height; i++)
	{
		printf("%s", mas[i]);
		if (i == 1) // строка по адресу [1] в массиве (начинается с [0])
			printf("   lvl %i   ", lvl); // уровень
		if (i == 3) // строка 3
			printf("   hit %i   ", hitCnt); // количество ударов
		if (i == 4) // строка 4
			printf("   max %i   ", maxHitCnt); // максимальное количество ударов

		/* ракетка будет в самом низу игрового поля -
		символ перевода строки \n ставим во всех строках,
		кроме последней: */
		if (i < height - 1)
			printf("\n");
	}
}

/* Функция позволяет перемещать ракетку: */
void moveRacket(int x)
{
	racket.x = x; // входной параметр x задаёт левый угол ракетке

	/* проверка местоположения ракетки;
	если она выходит за границы - возвращаем её обратно
	(она будет просто упираться в стенку): */
	if (racket.x < 1)
		racket.x = 1;
	if (racket.x + racket.w >= width)
		racket.x = width - 1 - racket.w;
}

/* Функция переводит каретку в левый верхний угол, чтобы
предотвратить мерцание экрана при его очистке функцией cls: */
void setcur(int x, int y)
{
	/* задаём координаты: */
	COORD coord;
	coord.X = x;
	coord.Y = y;

	/* перемещаем координаты в заданную точку: */
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

/* Функция показа номера уровня на экране перед началом игры (превью): */
void ShowPreview()
{
	system("cls"); // очистить экран, чтобы не создавать дублирующие изображения внизу
	printf("\n\n\n\n\n\n\n\n\n\n\n\n \t\t\t\t    LEVEL %d", lvl); // номер уровня
	Sleep(1000); // пауза на 1000 миллисекунд
}

/* Функция проверки на проигрыш: */
void CheckFaild()
{
	if (ball.iy >= height - 1) // если мячик на последней строчке игрового поля или ниже,..
	{
		run = FALSE; // ... он возвращается в исходное положение

		/* после вылета мячика начинается отсчёт его максимального количества ударов о ракетку: */
		if (hitCnt > maxHitCnt) // если текущее количество ударов больше, чем максимальное,..
			maxHitCnt = hitCnt; // ...то текущее будет становиться максимальным,..
		hitCnt = 0; // ...а счётчик ударов возвратится к 0
	}
}

/* Функция рассчитывает количество кирпичей на игровом поле: */
int lvlMapBrickCount()
{
	int cnt = 0;

	/* проходим по игровому полю:... */
	for (int j = 0; j < height; j++)
		for (int i = 0; i < width; i++)

			if (lvlMap[j][i] == c_brick) // ...если нашли кирпич - ...
				cnt++; // ...увеличиваем счётчик
	return cnt;
}

/* Функция проверки на победу: */
void CheckWin()
{
	if (lvlMapBrickCount() == 0) // если все кирпичи разбиты,..
	{
		lvl++; // ...переходим на следующий уровень
		if (lvl > 3) lvl = 1; // если прошли 3 уровень, возвращаемся к Уровню 1
		lvlMapInit(lvl); // инициализация соответствующей локации
		run = FALSE; // мячик снова привязан к ракетке
		maxHitCnt = 0; // счётчики максимального количества ударов...
		hitCnt = 0; // ...и текущего количества ударов мяча о ракетку обнуляются
		initRacket(); // инициализируем ракетку
		ObjArr_Clear(); // удаляем все объекты
		ShowPreview(); // показать превью при переходе на новый уровень
	}
}

/* Функция поведения мячика: запущен или привязан к ракетке: */
void BallWork()
{
	/* если мячик запущен,
	он начинает двигаться автоматически */
	if (run)
		autoMoveBall();

	/* в противном случае он следует за ракеткой */
	else
	{
		moveBall(racket.x + racket.w / 2, racket.y - 1);
		ball.alfa = -M_PI_2 - 0.5; // при ожидании запуска мячика угол всегда будет одинаковым
	}
}

/* Функция выстрела: */
void racketShout()
{
	/* стрелять можно только если переменная fireMode равна 1,
	при иных условиях механика стрельбы не доступна: */
	if (racket.fireMode != 1) return;

	/* создаём в центре ракетки объект типа ot_bullet, который будет лететь вертикально вверх: */
	ObjArr_Add(Obj_Create(racket.x + racket.w / 2, racket.y - 2,
		-M_PI_2, 0.5, ot_bullet));
	racket.fireMode += 10; // следующий объект можно создать только через 10 итераций
}

/* Функция уменьшает количество объектов для стрельбы каждую итерацию: */
void racketWork()
{
	/* уменьшаем переменную fireMode, если она больше 1: */
	if (racket.fireMode > 1)
		racket.fireMode--;
}

int main()
{
	initRacket(); // инициализировать ракетку
	initBall(); // инициализировать мячик
	lvlMapInit(lvl); // карта уровня
	ShowPreview(); // экран с номером предстоящего уровня

	/* Создаём цикл с постусловием, чтобы программа заново могла отображать объекты на экране: */
	do
	{
		BallWork(); // поведение мячика (статика или начало игры)
		ObjArr_Work(); // обработать все объекты в массиве
		racketWork(); // уменьшать переменную механики стрельбы каждую итерацию
		CheckFaild(); // проверить на проигрыши
		CheckWin(); // проверить на выигрыши

		lvlMapPut(); // поместить карту уровня в буфер вывода
		putRacket(); // поместить ракетку на игровое поле
		putBall(); // поместить мячик на игровое поле
		ObjArr_Put(); // поместить все объекты на карту
		show(); // показать всё игровое поле со статистическими данными
		if (GetKeyState('A') < 0) moveRacket(racket.x - 1); // если нажимаем A - ракетка двигается влево
		if (GetKeyState('D') < 0) moveRacket(racket.x + 1); // если нажимаем D - ракетка двигается вправо
		if (GetKeyState('W') < 0) run = TRUE; // если нажимаем W - запускается мячик (boolean run вместо FALSE становится TRUE)
		if (GetKeyState(VK_SPACE) < 0) racketShout(); // если нажимаем Пробел - стреляем
		Sleep(10); // замедление программы 10 миллисекунд
	} while (GetKeyState(VK_ESCAPE) >= 0); // пока не нажмём ESC для выхода из игры

	return 0;
}
